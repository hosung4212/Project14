 맨처음에 leave에서 rsp가 rbp로 이동하고 이걸 pop 한다. 그러면 ret 위에 rsp가 있는데 여기서 ret을 하면 pop rip 니까 rsp는 다음 인수를 가리키게 된다. 
그대로 pop rdi; ret를 하면 rdi에 값은 저장되고 rsp로 다시 rip가 이동하면서 다음명령어를 또다시 가리키게 되는데 이게 rop의 기초
원래 rip는 스택에서 움직이는게 아니라 +방향으로 계속 이동하기 때문에 다음 명령어로 계속 이동할 수 있다.

일단 처음에 read@plt (사용할 목적) write@plt (사용할 목적) read@got (변형할 목적) 3개를 얻어준다. 각자 다 오프셋이다. 
맨처음 read_got에 저장된 주소를 출력시킨다. 그러면 상대 프로그램에서 read가 어디에 저장되어 있는지 나온다.
이것과 symbols.read 를 이용해 라이브러리의 시작값을 구하고 symbols.system을 이용해 시스템의 주소를 구한다. 
시스템 함수의 주소+/bin/sn\00을 got read 위에 덮어주면 미리 써놓은 payload가 /bin/sh 를 인수로 가지는 system 함수를 실행해줄거다.
plt는 함수 주소가 아니라 맨처음 함수를 호출했을시에 링크된 라이브러리에서 함수의 주소를 가져오는 명령어가 들어있따. 그래서 rip가 plt를 가리키면 해당 명령어가 실행된다. 
got에는 라이브러리에 있는 실제 함수의 주소가 적혀있다. got를 변형시키고 plt를 호출하면 plt가 got에 저장되어 있는 변형된 값을 참조하여 실행한다. 이때 64비트 시스템이기 때문에 rdi에 /bin/sh 주소를 넣고 system을 실행기시키면 system("/bin/sh") 이 된다.

got를 출력해야하는 이유. e.got['read'] 는 주소이다. 이 안에 있는 값을 읽으려면 read(0,got_read) 명령어를 써야한다. (포인터로 주소에 있는 값 읽는거랑 비슷)
