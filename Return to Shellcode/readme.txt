파이썬 언어를 잘 써야했다.
먼저 원격연결까지는 똑같았는데 내가 원했던 기능을 하나 찾았다.
slog를 쓰면 쉘코드 중간중간에 내가 의도한 동작들이 잘 이루어지는지 추적할 수 있었다.
일단 slog를 쓰면서 보면 
buf: 가 나오기 전까지 recvuntil 로 받고 그다음 buf의 주소를 출력해주기.때문에 이를 받는다.
 문자열로 출력이 되는 값이라 int형으로 바꿔서 저장해주고 나중에 p64를 이용해서 쉘코드에 넣어준다.
일단 buf의 주소를 받았으면 그 다음 Input: 까지 기다렸다가 버퍼 오버플로우를 유도해준다. 일단 그 전에 rsp와 버퍼 사이의 거리를 알려주므로 이 값을 받아두고 거기서 8을 빼준다. canary의 위치이다. 
먼저 canary는 맨 처음 값을 NULL문자로 보호하므로 거리가 88일때 89로 오버플로우를 해줘서 canart값을 추출해준다. 그럼 payload로 A를 89번 보낸거니까. 
이게 그대로 출력되고 그 뒤에 카나리 값 후반 7바이트가 출력될 것이다.
그러면 이걸 canary= u64(NULL+recv(7))로 받으면 된다. 그리고 나중에 p64(canary)로 바꿔준다. 
그다음 쉘코드를 shellcraft로 만든다. (이거 엄청 편리한데 이제 알았다)
그상태에서 payload를 작성하면 되는데 쉘코드 + "A"로 88자리 까지 채우고 p64(canary) 해주고 rsf값 b*0x8로 덮어주고 그 뒤에 p64(buf)로 돌아갈 주소를 바꿔준다. 
Input: 다음에 페이로드가 전송될 수 있도록 sendlineafter을 작성해준다.


마지막 질문? 
왜 버퍼는 int값으로 받고 카나리는 u64로 받을까. 둘 다 p64를 이용해 리틀엔디언 주소값으로 바꾸는데 무슨 차이지?
A: 버퍼는 주소값이고 카나리는 검증하는 일반 값이다. 버퍼는 주소를 리틀엔디언 방식으로 다시 저장할 필요가 있기 때문에 int를 써서 원래의 순서를 뒤바꾸지 않는다. 그리고 p64를 이용해 이 값을 리틀엔디언으로 바꿔준다. 
카나리는 원래 받은 값을 그대로 쓰면 되는데 출력된 문자열을 u64를 이용해서 정확히 해석하는 것이다. u64를 이용하면 리틀엔디언 처럼 순서가 바뀌게 되고 다시 p64를 이용하면 이 순서가 원래대로 돌아오면서 맨 처음 출력받은 값을 그대로 다시 입력할 수 있다. u64가 p64의 역함수라고 보면 된다.
