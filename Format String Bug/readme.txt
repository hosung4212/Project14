오랜만에 하느라 좀 헷갈렸다.
일단 rsp는 함수에서 저장되 변수들을 가리킨다. 
rip는 명령어를 가리키고
만약 포맷 스트링 버그에서 쓰이는 변수가 있다면 그게 rsp에서 얼마나 떨어져 있는지 부터 확인해야 한다. 
여기서는 rsp에 바로 buf 변수가 있었고 "%1337c%8$n" 이게 10글자니까 A를 6개 더 넣은 다음 changme의 주소를 넣어서 rsp의 0x10에 있게 했다. 그럼 3번째에 있는거고 5개의 레지스터를 먼저 인자로 사용하니까 8$n을 써준것이다. 
이때 인자는 주소값을 참조해서 그 주소에다가 넣는 것이기 때문에 포맷스트링 버그를 사용한다고 하면 변수의 주소를 먼저 알아내서 그 주소를 인자로 사용하게 해야한다. 그리고 그걸 %n을 써서 조작하는 것임.



형식 지정자 정리 (printf문에서)
정리하자면 
%7$s 이런식으로 되어 있으면 7번째 인자를 문자열로 출력
%n 이면 해당하는 인자에  여태까지 쓰인 문자 수를 입력한다.
$가 있으면 $앞의 수 번째 인자를 참조한다.
%31337c%8$n 이런식이라면 31337을 문자형으로 쓰고 8번째 인자에 이 숫자를 쓰겠다는거 (왜 이렇게 될까? 만약 인자에 %c로 인자를 읽는데 인자에 뭐가 들어있던지 일단 최소넓이 31337로 고정이 되니까 일단 앞에 쓰이는 글자는 31337 이다. 이 상태에서 %8$n을 하면 8번째 인자에 여태 쓰인 글자수를 넣는다.)
%*d 이런식이면 인자를 두개 쓰는데 앞에 쓴 인자를 최소 크기로 두갰다는 거임
%8d 이렇게 되어 있으면 최소너비가 8 이라는 것. 만일 인자의 크기가 8보다 작으면 비는 공간을 공백으로 채운다. 
그럼 %n으로 숫자를 받고서 이걸 %*n을 이용해서 그 숫자를 받은 인자를 이용해 원하는 값을 원하는 위치에 넣을 수도 있다.
근데 만약에 주소가 엄청 크면 이렇게 넣는건 무리다. 
그럼 %hn , %hhn 으로 2바이트 , 1바이트 씩 쓸 수 있는데 (h가 half인 듯 )
그러면 이렇게 넣으면 된다. 만약 deadbeef를 넣고 싶으면 

fstring = f"%{0xad}c%16$hhn".encode()

fstring += f"%{0xbe - 0xad}c%15$hhn".encode()

fstring += f"%{0xde - 0xbe}c%17$hhn".encode()

fstring += f"%{0xef - 0xde}c%14$hhn".encode()

이런식으로 큰 숫자부터 뒤에있는거 빼면서 순서맞춰 넣으면 된다. 

이게 좀 복잡하네 ..
