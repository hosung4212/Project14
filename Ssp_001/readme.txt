파이썬 활용을 더 배웠다.
sendline과 send의 차이는 끝에 "\n"을 붙이냐 붙이지 않느냐이다.
보통 send는 read에 사용하고 나머지는 다 sendline을 사용해서 셸코드를 전달한다고 보면 된다.
참고로 파이선에서는 '," 의 차이가 없다. 그냥 둘 다 똑같다.뒤에 개행문자 안넣는다.
내가 가진 파일을 e= ELF("파일이름")으로 파일 정보들을 다룰 수 있게 한다.
이 파일에서는 쉘권한을 주는 get_shell 함수가 있었기 때문에 
get_shell = e.symbols('get_shell')로 함수의 주소를 가져올 수 있었다.
일단 대부분의 입력함수는 입력을 문자열로 받기 때문에 입력하는 숫자에 str()을 해줘야한다. 그래야 내가 원하는 숫자를 입력할 수 있다.
첫번째로 버퍼오버플로우를 발생시킬 수 있는 부분은 Pfmf 입력했을 때 read부분이다. box_print 함수를 보면 배열의 뒤에 접근할 수 있기 때문에 이를 이용한다.
먼저 메모리가 초기화된 순서를 보면 box가 나중에 push된 것을 알 수 있다. box가 64바이트고 name이 64비트 이기 때문에 디버깅을 해서 보면 카나리값을 129,130,131,132 바이트 뒤에 있는 것을 알 수 있다.
print_box 함수가 바이트를 하나씩 출력하기 때문에 이를 넣어주면 된다. 다만 주의해야하는 것은 저장된 순서다. 132부터 129까지이고 배열에서는 0부터 시작하니까 131부터 128까지 데이터를 canary+= 로 받으면 (131)(129)(128)(127) 로 입력이 되어 있을것이다. 어차피 카나리값은 리틀엔디언을 신경 안써도 되니 왜 반대로 받은건지 의아할 수 있는데 일단 recv로 받은 문자는 전부 문자열이다. 그리고 이걸 그대로 쓸 수가 없는게 바이트로 이걸 바이트로 그래도 변환하는 방법을 내가 몰라서이다. 그러니 일단 역순으로 받고 그걸 int형식으로 바꿔준 다음에 p32함수를 사용해서 이걸 원래 바이트 형식의 값으로 되돌리는게 훨씬 쉽다.

다른 방법은 (사본)에 만들어 뒀는데 순서대로 바꿔서 정수형->바이트형으로 받는 방식이다. 크게 다를건 없다. 


그리고 int(canary,16) 은 카나리가 16진수의 문자열로 되어있을 때 이걸 정수형으로 바꿔주는 역할을 한다. 
