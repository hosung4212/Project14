하 오랜만에 풀어서 너무 힘들었다. 먼저 got와 plt를 복습해보자
우리가 함수를 호출하면 함수는 plt에서 함수를 호출하는데 plt는 got를 참조한다.
만약 한번이라도 같은 함수를 호출한 적이 있다면 got에는 실제 함수의 주소가 적혀있어서 그대로 그걸 참조해 가져온다. 그렇지 않다면 링커가 실제 함수 주소를 가져오는 다른 함수를 시작하고 호출하려 했던 함수를 호출한다. 그리고 그 후에 got에 이 실제 함수 주소를 적는다.
그렇다면 우리가 덮어쓰려면 got를 덮어써야한다. plt가 got를 참조하니까 got에 잘못된 주소를 써넣으면 plt는 내가 유도한 곳을 참조해서 실행한다.
이번에 다른점이 있는데 x86 운영체제 32비트에서는 인수를 다 스택에다가 넣는다. 그렇기 때문에 read 라면 뒤에 ret 주소 이후에 stdin파일,써넣을 주소,바이트수 3개의 인수를 다 적어두고 함수가 끝나면  ret주소로 돌아가서 pop을 3번하고 ret 하게 만든다. 맨처음에는 write로 read_got에 있는 값을 leak하고 이 값이 실제 read 값이니까 이걸 이용해서 system 함수 값의 실제 위치를 찾아낸다. 그리고 read_got에 system 함수의 주소를 덮어쓰면 된다. 그리고  read 함수를 호출한다. 시스템 함수는 주소를 인자로 받기 때문에 인자를 "/bin/sh"의 주소로 하는데 여기서 "/bin/sh" 를 미리 read_got에 값을 덮어씌울 때 써두었기 때문에 인자를 (read_got)+0x4 로 해뒀다. 
이걸 이용해서 쉘 코드를 작성하면 send_Code.py가 된다.
이번 rop에서 봐야하는 부분은 plt 함수와 got함수는 실행 파일에 있지만 실제 함수의 주소는 라이브러리 파일에 있기 때문에 오프셋을 구할 때 libc 와 e 로 나눠서 구한다는 것이다.
