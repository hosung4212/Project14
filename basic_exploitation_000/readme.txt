이제 비슷한 방법으로 구했는데 맨 처음에 보면 0x80비트 짜리로 변수를 만들었는데 scanf가 142개 까지 받을 수 있게 해뒀다.
32비트 운영체제이기 때문에 128비트 + (rsp)4비트 + (rip 복귀)4비트 이기 때문에 132비트 후에 들어오는 값을 실행시킨다는 걸 볼 수 있다.
서버의 프로그램을 실행시키면 버퍼의 주소가 나오는데 버퍼 안에 셸코드를 넣어두고 rip가 복귀하는 곳에 버퍼의 주소를 넣어두면 된다.
단 주의해야할 점이 있는데 첫번째가 32비트 운영체제이기 때문에 eax,eip 등등의 레지스터를 사용해야하고 두번째로 scanf가 0x0b를 받을 수 없기 때문에 
실행을 할 때 al로 만들어두고 1씩 3번 더하는게 좋다. 0x0b가 eax가 들어가는데 32비트 syscall테이블에서 execve를 뜻하기 때문에 반드시 써야한다.
일단 저번처럼 파일이름을 리틀엔디언으로 넣고 execve를 실행하는 어셈블리어 파일을 만든다.
그리고 그 파일을 오브젝트 파일로 만들고 디스어셈블해서 쉘 코드가 나오게 만든다 
추출해서 /x00 형태로 만들어보니 32개의 바이트가 나오기 때문에 일단 (셸코드 32비트 + 'A' 100비트 + 버퍼의 주소) 이런식으로  셸코드를 보내야한다.
문제점이 있다면 출력이 먼저 나오고 입력이 나와야한다는 것이다. 그래서 맨 처음 나오는 buf = ( 을 받아줄 필요가 있다 그 후에 버퍼의 주소를 주는데 이것을 우리가 셸코드 맨 뒤에 넣어야한다. r.recvuntil(b"buf = (") 이걸로 글을 받는걸 기다리고 buf_address = int(r.recv(10),16)이걸 사용하여 그 다음에 나오는 buf 주소를 받아준다. 
그리고 sendline으로 보내고 interaction을 해준다.
다만 python 에 대해서 정확히 알지 못하는거 같다. 자세히 알아보자
